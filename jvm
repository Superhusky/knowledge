1、数据类型
	{
		1、基本类型:基本变量保存的是原始值,即代表的就是值本身
		2、引用类型:引用类型的变量保存的是引用值,引用值代表了某个对象的引用,对象本身存放在这个值所表示的地址的位置
	}

2、堆栈
	{
		1、栈是运行时的单位:表示程序如何运行的,存储的是当前线程的运行状态,方法返回值,局部变量等
			{
				java中一个线程就会有一个与之对应的线程栈,因为处理逻辑不同,所以有不同的栈
			}
		2、堆是存储的单位:数据存放在哪,只负责存放对象信息
			{
				堆是所有线程所共享的。
			}
	}

3、堆栈分离
	{
		1、从设计的角度来说,栈是处理逻辑,堆是数据存储.这样分开使得处理逻辑更加清晰 =>隔离模块化的思想

		2、使得堆中的对象被多个栈共享(多个线程访问一个对象)
			{
				1、数据交换方式 共享内存

				2、堆中共享常量和缓存可以被所有栈访问,节省空间
			}

		3、栈由于运行时的需要,比如保存系统上下文,需要进行地址段的划分,由于栈只能向上增长,因此限制了栈的存储能力。堆中的对象可以动态增长.堆栈分离可以保证,动态增长成为可能，而栈中只需要保存一个地址就可以了

	}

4、在java中Main函数就是栈的起始点

5、堆栈中存储
	{
		1、堆中存储的是对象

		2、栈中存储是基本数据类型和堆中对象的引用,对象的大小是没有办法估量的,对象在栈中只需要一个4byte的引用就可以了

		3、为什么不把基本数据类型放到堆中,因为基本数据类型一般是1-8个字节占用的比较少,而且是不会出现动态增长的 -- 长度固定
	}

6、java参数传递
	{
		java程序在运行的时候只在栈中进行,因此参数传递的时候,只存在传递基本数据类型和对象的引用的问题,不会传递对象本身

		在运行栈中,基本类型和引用的处理是一样的,都是传值.将对象的引用(4byte的对象位置值,传递给了其他对象,所以在某种程度上来说,还是值传递)

		当程序解析对象引用值,查找到堆中对象的值的时候,做出的修改可以保持,即修改堆中对象

		
	}

7、引用类型
	{
		1、强引用:虚拟机生成的引用,强引用环境下,gc需要判断当前对象是否被强引用,如果是则不会被垃圾回收

		2、软引用:作为缓存来使用,软引用会根据当前内存使用状况来决定是否对引用进行回收,如果虚拟机在发生OutOfMemory的时候,一定没有软引用

		3、弱引用:作为缓存来使用,并且一定会被gc回收,因为生命周期只有在一个gc内

		4、一般引用的是强引用,可控性高。
	}

8、java对象大小
	{
		1、java中所有对象继承于Object类,一个object类大小为8yte.所以java对象最小为8byte(堆中对象所占大小) + 4byte(栈中引用地址所占大小).而且由于java对象是8的整数倍,所以分配内存最小为16byte.

		2、基本包装类型的大小至少是16byte。这个内存占用是很恐怖的，它是使用基本类型的N倍(N>2) = > 少用包装类

		3、java对象的内存布局:对象头(Header),实例数据(Instance Data)和对齐填充(Padding)
	}